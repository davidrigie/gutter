# Gutter â€” Build Plan

A markdown editor combining the best of Typora and Zettlr with robust Google Docs-style commenting. Built with Tauri.

---

## Vision

Gutter is a local-first, WYSIWYG-ish markdown editor where **comments are a first-class feature**. The name refers to the typographic gutter â€” the margin space where annotations live. The editor should feel fast, clean, and premium, like a native app, not an Electron wrapper.

---

## Tech Stack

| Layer | Choice |
|---|---|
| Shell | Tauri v2 |
| Frontend | React + TypeScript (strict mode) |
| Editor core | TipTap v2 (ProseMirror) |
| Markdown parsing | remark / unified |
| Styling | Tailwind CSS |
| State management | Zustand |
| Testing | Vitest (unit/integration), Playwright (e2e) |

---

## Comment System Spec

This is the most novel part of Gutter and needs the most precise specification.

### The Three-File Model

Every commented document produces up to three files:

```
my-document.md                # The document with lightweight inline comment markers
my-document.comments.json     # Structured thread data (source of truth for Gutter)
my-document.comments.md       # Auto-generated human-readable companion for non-Gutter users
```

### File 1: Inline Markers in the `.md` File

Comment anchors live directly in the markdown as standard HTML `<mark>` and `<sup>` tags:

```markdown
The strategy <mark>should focus on long-term growth</mark><sup>[c1]</sup> rather than
<mark>quick wins</mark><sup>[c2]</sup> that don't compound.
```

**Canonical marker format:**

```
<mark>HIGHLIGHTED_TEXT</mark><sup>[cN]</sup>
```

**Marker rules:**
- `N` is a positive integer, sequential per document: `c1`, `c2`, `c3`
- IDs are stable â€” deleting `c2` does not renumber `c3`
- New comments get `max(existing IDs) + 1`

**Detection regex:**

```
/<mark>([\s\S]*?)<\/mark><sup>\[c(\d+)\]<\/sup>/g
```

**Edge cases:**

| Case | Expected behavior |
|---|---|
| Bare `<mark>` without a following `<sup>[cN]</sup>` | Not a comment. Render as normal HTML. |
| `<sup>[c1]</sup>` without a preceding `</mark>` | Not a comment. Render as normal HTML. |
| Nested markers (overlapping comments) | Both are valid. Inner marker resolves first. |
| Marker spanning a line break | Valid. Highlighted text spans multiple lines. |
| Marker inside a code block or inline code | Not a comment. Literal text â€” don't parse. |
| Marker inside a blockquote | Valid. |
| Malformed/unclosed `<mark>` | Ignore. Pass through as-is. |
| Marker ID in `.md` with no JSON entry | Show highlight with "missing comment data" indicator. |
| JSON entry with no matching marker in `.md` | Show as "unanchored comment" in sidebar with warning. |

**Rendering in Gutter:**
- `<mark>` tags render as subtle colored highlights (not raw HTML) â€” clickable
- `<sup>` tags are hidden
- Clicking a highlight focuses the matching thread in the sidebar
- Resolved comments render with a muted/dimmed highlight
- In source mode, raw HTML is visible and editable

**Rendering in other markdown viewers:**
- `<mark>` renders as a yellow highlight (most renderers)
- `<sup>[c1]</sup>` renders as superscript â€” reader can look up the ID in the companion file

### File 2: `*.comments.json` â€” Thread Data

**Data model:**

```typescript
interface CommentMessage {
  id: string;          // Unique message ID, format: "m_" + nanoid(8)
  author: string;      // Display name
  timestamp: string;   // ISO 8601 UTC
  body: string;        // Plain text (no markdown in comments for MVP)
}

interface CommentThread {
  thread: CommentMessage[];  // Ordered. First entry = original comment.
  resolved: boolean;
  resolvedBy?: string;
  resolvedAt?: string;       // ISO 8601 UTC
  createdAt: string;         // ISO 8601 UTC
}

interface CommentsFile {
  version: 1;
  comments: Record<string, CommentThread>;  // Keyed by "c1", "c2", etc.
}
```

**Rules:**
- Created on first comment, not on document creation
- Deleted entirely when last comment is deleted (no empty files)
- Written with 2-space indented JSON for readable git diffs

### File 3: `*.comments.md` â€” Generated Companion

Auto-generated from the JSON + inline markers. Never hand-edited.

**Example output:**

```markdown
# Comments â€” my-document.md

*Generated by Gutter. Do not edit â€” regenerated on save.*

---

> **[c1]** on "should focus on long-term growth"

**Dave** â€” Feb 13, 2026 10:30 AM
Should we rephrase this? "Long-term growth" is vague.

**Sarah** â€” Feb 13, 2026 10:35 AM
How about "sustainable revenue growth"?

âœ… *Resolved by Dave â€” Feb 13, 2026 10:42 AM*

---

> **[c2]** on "quick wins"

**Dave** â€” Feb 13, 2026 11:00 AM
Do we need this contrast? Feels slightly passive-aggressive.

ğŸŸ¡ *Open*

---

*2 comments (1 resolved, 1 open)*
```

**Generation rules:**
- Quoted anchor text extracted from `<mark>` tags in the `.md` â€” truncate to 80 chars with "..."
- Threads listed in document order (by position of marker), not creation time
- Timestamp format: `Mon DD, YYYY H:MM AM/PM`
- Resolution status: `âœ… *Resolved by {author} â€” {timestamp}*` or `ğŸŸ¡ *Open*`
- Footer: total count with resolved/open breakdown
- Regenerated on every save
- Deleted when no comments remain

---

## Editor Requirements

### WYSIWYG Rendering

The editor should render markdown as styled content, not raw syntax:

| Markdown element | Rendering |
|---|---|
| `# Heading` | Styled heading (not raw `#`) |
| `**bold**` | Bold text |
| `*italic*` | Italic text |
| `~~strikethrough~~` | Strikethrough text |
| `` `code` `` | Inline code with monospace + background |
| Fenced code blocks | Syntax-highlighted block with language detection |
| `[link](url)` | Clickable styled link |
| `![alt](url)` | Inline image with drag-to-resize |
| Tables | Editable rendered tables |
| Blockquotes | Styled blockquote |
| Lists (bullet/ordered) | Rendered lists with proper nesting |
| `---` | Horizontal rule |
| YAML frontmatter | Collapsible metadata block |

### Source Mode

- `Cmd+/` toggles between WYSIWYG and raw markdown
- Edits in either mode are reflected when toggling back
- Visual indicator of current mode

### Markdown Round-Trip Fidelity

This is critical. The file on disk must always be valid, standard markdown.

- Parse: MD string â†’ editor document model
- Serialize: editor document model â†’ MD string
- **Requirement:** `serialize(parse(md))` must be functionally equivalent to `md` â€” no content loss, no format corruption. Whitespace normalization is acceptable.
- Inline HTML (including comment markers) must survive the round trip exactly

**Test fixture â€” this file must round-trip cleanly:**

```markdown
# Heading 1

## Heading 2

A paragraph with **bold**, *italic*, ~~strikethrough~~, `inline code`, and a [link](https://example.com).

- Bullet item 1
- Bullet item 2
  - Nested bullet

1. Ordered item
2. Ordered item

> A blockquote with **bold** inside

` ` `javascript
const x = 1;
` ` `

![alt text](image.png)

---

Some text with <mark>highlighted</mark><sup>[c1]</sup> content.

A bare <mark>highlight without comment</mark> should survive too.
```

*(Note: the spaces in the fenced code block delimiters above are for escaping only â€” the actual test fixture should use real triple backticks.)*

### File Operations

- Open file: native file dialog, `Cmd+O`
- Save file: `Cmd+S`, debounced auto-save (2 sec after last keystroke)
- Dirty indicator in title bar or status bar
- File watcher: detect external changes and prompt to reload

### Keyboard Shortcuts

| Action | Shortcut |
|---|---|
| Bold | `Cmd+B` |
| Italic | `Cmd+I` |
| Strikethrough | `Cmd+Shift+X` |
| Inline code | `Cmd+E` |
| Link | `Cmd+K` |
| Toggle source mode | `Cmd+/` |
| Toggle file tree | `Cmd+\` |
| Toggle comments panel | `Cmd+Shift+C` |
| New comment | `Cmd+Shift+M` |
| Next comment | `Cmd+Shift+N` |
| Previous comment | `Cmd+Shift+P` |
| Open file | `Cmd+O` |
| Save file | `Cmd+S` |
| Zen mode | `Cmd+Shift+F` |
| Command palette | `Cmd+Shift+P` |
| Find | `Cmd+F` |
| Find and replace | `Cmd+H` |
| Dark/light toggle | `Cmd+Shift+D` |

---

## Comment UX Requirements

### Create Comment

1. User selects text and presses `Cmd+Shift+M`
2. Selection is wrapped with comment markers
3. New entry created in JSON sidecar
4. Comment input opens in sidebar, focused
5. User types and presses `Enter` to submit
6. If user presses `Escape` without typing, the marker and JSON entry are removed (clean cancel)

### Reply

1. User clicks an existing thread or highlight
2. Reply input appears at bottom of thread
3. `Enter` submits, message appended to thread

### Resolve

1. Click checkmark on thread
2. Thread marked resolved with who/when
3. Highlight becomes muted/dimmed
4. Thread collapses in sidebar (expandable)
5. "Show resolved" toggle in sidebar header

### Delete

1. Click delete on thread â†’ confirmation dialog
2. Markers removed from `.md`, entry removed from JSON
3. If last comment, JSON and companion files deleted

### Navigate

- `Cmd+Shift+N` / `Cmd+Shift+P` cycle through comments in document order
- Clicking a highlight scrolls sidebar to that thread
- Clicking a thread scrolls editor to that highlight

---

## UI Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          â”‚                            â”‚              â”‚
â”‚  File    â”‚                            â”‚   Comments   â”‚
â”‚  Tree    â”‚      Editor Canvas         â”‚   Panel      â”‚
â”‚          â”‚                            â”‚              â”‚
â”‚  (left)  â”‚      (center)              â”‚   (right)    â”‚
â”‚          â”‚                            â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Status   â”‚
                    â”‚ Bar      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Editor canvas should dominate â€” minimal chrome
- Both sidebars independently toggleable and resizable
- Status bar: word count, cursor position, file path, save status, comment count
- Dark/light mode with system preference detection
- Zen mode: hide both sidebars, center and constrain editor width

### File Tree (left sidebar)

- Show folder structure when a workspace is opened
- Collapse/expand directories
- Click file to open
- Show `.md` files prominently, dim non-markdown files
- Don't show `.comments.json` or `.comments.md` files in the tree (they're internal)

### Comments Panel (right sidebar)

- Header: title, comment count badge, "Show resolved" toggle
- Threads listed in document order
- Each thread shows: quoted anchor text (truncated), all messages with author/timestamp, resolve + delete actions
- Active thread (selected) visually highlighted
- Reply input at bottom of each thread

---

## Build Phases

Each phase is broken into tasks that should be completable as discrete units of work. Tasks within a phase are ordered â€” later tasks may depend on earlier ones.

### Phase 1: Core Editor

**1.1 â€” Project scaffold**
Scaffold a Tauri v2 + React + TypeScript project with Tailwind, Zustand, and Vitest configured.
*Done when:* `npm run tauri dev` opens a window, `npm run test` runs with a passing smoke test, TypeScript compiles clean.

**1.2 â€” Basic TipTap editor**
Get a TipTap editor rendering in the window with all the formatting from the WYSIWYG table above working via keyboard shortcuts. Use hardcoded content for now â€” no file I/O yet.
*Done when:* Editor renders styled content. All formatting shortcuts work.

**1.3 â€” Markdown â†’ editor parser**
Build the parser that converts a markdown string into a TipTap editor document. Must handle all elements in the WYSIWYG table plus HTML passthrough (important for comment markers). Write unit tests for each element type.
*Done when:* All parser unit tests pass. HTML tags are preserved, not stripped.

**1.4 â€” Editor â†’ markdown serializer**
Build the serializer that converts the TipTap editor document back to a markdown string. Write a round-trip test: `serialize(parse(fixture))` must produce functionally equivalent markdown. Use the test fixture in the spec.
*Done when:* Round-trip test passes. No content loss. HTML passthrough preserved exactly.

**1.5 â€” File I/O**
Wire up open/save via Tauri. Native file dialog for open. `Cmd+O`, `Cmd+S`. Debounced auto-save. Dirty indicator.
*Done when:* Can open a `.md` file, edit it, save it, reopen it, and see the same content.

**1.6 â€” Code block syntax highlighting**
Add syntax highlighting to fenced code blocks with language detection. Support at least: javascript, typescript, python, rust, html, css, json, bash, go, sql.
*Done when:* Code blocks with language tags render with highlighting. Editing inside them doesn't break anything.

**1.7 â€” Source mode**
`Cmd+/` toggles between WYSIWYG and raw markdown editing. Edits in either mode transfer when toggling.
*Done when:* Toggle works bidirectionally without data loss.

**1.8 â€” Layout shell and theming**
Three-panel layout with resizable, toggleable sidebars (left: file tree placeholder, right: comments placeholder). Status bar. Dark/light mode. Zen mode.
*Done when:* Layout works. Sidebars toggle and resize. Theme switching works. Looks clean and intentional.

### Phase 2: Comments

**2.1 â€” Comment data layer**
Define TypeScript types from the spec. Build the Zustand store for comment state. Build Tauri backend for reading/writing/deleting the JSON sidecar. Write unit tests for store actions.
*Done when:* Store manages comment state correctly. Backend reads/writes JSON files. Tests pass.

**2.2 â€” Comment marker parsing and serialization**
Extend the markdown parser (1.3) to detect `<mark>...<sup>[cN]</sup>` patterns and produce comment anchor marks in the editor. Extend the serializer (1.4) to emit the correct HTML. Handle all edge cases from the spec table. Write unit tests.
*Done when:* Markers round-trip cleanly. Edge cases pass. Bare `<mark>` without comment ID is not treated as a comment.

**2.3 â€” Comment highlight rendering**
Build the TipTap mark extension that renders comment anchors as clickable highlights in the editor. Clicking sets the active comment. Style: subtle highlight (default), stronger highlight (active), muted (resolved).
*Done when:* Highlights render. Clicking one sets it as active. Overlapping highlights are distinguishable.

**2.4 â€” Comments panel UI**
Build the right sidebar: thread list, thread component with messages, reply input, resolve/delete buttons. Threads ordered by document position. Active thread highlighted and scrolled into view.
*Done when:* Panel renders threads from the store. Visual state (active, resolved) is correct.

**2.5 â€” Comment creation flow**
Wire the full flow: select text â†’ `Cmd+Shift+M` â†’ marker created â†’ sidebar input focused â†’ submit or cancel. On save, markers are persisted to the `.md` file and thread data to the JSON sidecar.
*Done when:* Can create a comment, save, close, reopen, and see the comment intact. Cancel removes all traces.

**2.6 â€” Reply, resolve, delete, navigate**
Implement all remaining comment operations per the UX spec. Navigation (`Cmd+Shift+N/P`) cycles through comments in document order.
*Done when:* All CRUD operations work. Resolved threads are visually distinct and toggable. Delete cleans up all files. Navigation works.

**2.7 â€” Companion file generator**
Build the generator that produces `*.comments.md` from the JSON sidecar + inline markers, following the template in the spec. Auto-runs on save. Deletes the file when no comments remain. Write a test with sample input/output.
*Done when:* Companion file matches the spec template. Generated on save. Cleaned up when empty.

### Phase 3: File Management

**3.1 â€” File tree**
Left sidebar showing folder structure when a workspace folder is opened. Collapse/expand. Click to open. Hide `.comments.json` and `.comments.md` files.
*Done when:* Can open a folder, browse its tree, and open files from it.

**3.2 â€” Tabs**
Support multiple open files with a tab bar above the editor. Click to switch. Close button. Dirty indicator per tab.
*Done when:* Multiple files open in tabs. Switching preserves state. Dirty files prompt before close.

**3.3 â€” File watcher**
Detect when an open file changes on disk (external edit). Prompt to reload or keep current version.
*Done when:* External edit triggers a reload prompt.

**3.4 â€” Drag and drop**
Drop `.md` files onto the window to open them. Drop images into the editor to embed them (copy to workspace, insert markdown image reference).
*Done when:* Both file and image drop work.

### Phase 4: Polish

**4.1 â€” Command palette**
Fuzzy-search command palette listing all available actions.
*Done when:* Palette opens, searches, and executes commands.

**4.2 â€” Find and replace**
`Cmd+F` for find, `Cmd+H` for find and replace. Highlight matches. Case-sensitive and regex toggles.
*Done when:* Find highlights matches. Replace works for single and all.

**4.3 â€” Frontmatter UI**
YAML frontmatter renders as a collapsible metadata block, not raw YAML. Editable.
*Done when:* Frontmatter renders cleanly. Edits persist.

**4.4 â€” Image handling**
Paste images from clipboard. Drag to resize inline images.
*Done when:* Paste and resize work.

**4.5 â€” Export**
Export current document as PDF or HTML.
*Done when:* Exports produce reasonable output.

**4.6 â€” Visual polish**
Refined typography, animations, app icon, about screen.
*Done when:* The app looks and feels premium.

---

## Testing Requirements

### Unit tests (Vitest)

- **Markdown parser:** one test per element type from the WYSIWYG table. Comment marker detection with all edge cases from the spec.
- **Markdown serializer:** one test per element type. Comment marker emission.
- **Round-trip:** `serialize(parse(fixture))` â‰ˆ `fixture` for the test fixture in the spec.
- **Comment store:** all actions (add, reply, resolve, delete). ID generation. Edge cases (delete last comment removes file).
- **Companion generator:** given sample `.md` + sample JSON, assert output matches expected companion markdown.

### E2E tests (Playwright)

- Open a `.md` file â†’ verify content renders correctly
- Edit â†’ save â†’ reopen â†’ verify persistence
- Create comment â†’ verify highlight + sidebar â†’ save â†’ reopen â†’ verify persistence
- Reply, resolve, delete flows
- Source mode toggle round-trip

---

## Key Design Decisions

### Why TipTap/ProseMirror over CodeMirror?

CodeMirror is a code editor. WYSIWYG markdown requires a rich-text document model. ProseMirror's schema-driven approach maps naturally to markdown's block/inline structure. TipTap provides a clean React integration layer and has collaboration primitives for potential future real-time editing.

### Why the three-file model for comments?

**Inline markers (in `.md`)** solve anchor drift â€” the anchor *is* the content, so it moves with edits naturally. External editors preserve HTML tags.

**JSON sidecar** stores thread data (replies, timestamps, resolution state) that would clutter the markdown if inlined.

**Generated companion** bridges the gap for non-Gutter users â€” anyone can read the comment threads in a standard markdown viewer or GitHub PR.

### Why `<mark>` + `<sup>` for markers?

`<mark>` is a standard HTML5 element meaning "highlighted for reference." Most markdown renderers pass it through and render a highlight. `<sup>` is universally rendered as superscript. Together they degrade gracefully everywhere while being machine-parseable for Gutter.

### Why Tauri v2?

Multi-window support, mobile targets, smaller bundles than Electron, Rust backend for file I/O performance. v2 avoids a migration from v1 later.

---

## Project Structure

```
gutter/
â”œâ”€â”€ src-tauri/               # Rust backend
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ commands/        # Tauri commands (file I/O, comments, workspace)
â”‚   â”‚   â””â”€â”€ companion.rs     # .comments.md generator
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ tauri.conf.json
â”œâ”€â”€ src/                     # React frontend
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Editor/          # TipTap editor, extensions, markdown parser/serializer
â”‚   â”‚   â”œâ”€â”€ Comments/        # Comments panel, threads, input
â”‚   â”‚   â”œâ”€â”€ FileTree/        # File tree sidebar
â”‚   â”‚   â”œâ”€â”€ StatusBar.tsx
â”‚   â”‚   â””â”€â”€ CommandPalette.tsx
â”‚   â”œâ”€â”€ stores/              # Zustand stores (editor, comments, workspace)
â”‚   â”œâ”€â”€ hooks/               # Custom hooks for file ops, comments
â”‚   â”œâ”€â”€ styles/              # Editor CSS, theme variables
â”‚   â””â”€â”€ types/               # TypeScript interfaces
â”œâ”€â”€ tests/                   # Test fixtures and e2e tests
â”œâ”€â”€ package.json
â”œâ”€â”€ tailwind.config.js
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

---

## Open Questions

1. **Author identity** â€” MVP: configurable name in settings. Future: integrate with git config.
2. **File portability** â€” Renaming/moving a `.md` file should move the sidecar and companion with it. Enforce via app, or rely on the naming convention for manual moves.
3. **Companion in git** â€” Provide a `.gitignore` template. Recommend: commit both `.comments.json` and `.comments.md`, or just the companion for lighter footprint.
4. **Marker collision** â€” Users who intentionally write `<mark>` in their markdown: Gutter only treats `<mark>...<sup>[cN]</sup>` pairs as comments. Bare `<mark>` is left alone.
5. **Future: real-time collaboration** â€” TipTap supports Yjs for real-time multi-user editing. The JSON sidecar would need to be replaced with a CRDT-based store. The inline marker approach is compatible. This is a v2+ concern.
