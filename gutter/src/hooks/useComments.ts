import { useCallback } from "react";
import { invoke } from "@tauri-apps/api/core";
import { useCommentStore } from "../stores/commentStore";
import { useEditorStore } from "../stores/editorStore";
import { fileName as pathFileName } from "../utils/path";
import type { CommentsFile } from "../types/comments";

export function useComments() {
  const { loadComments, getCommentsFile, setFilePath } =
    useCommentStore();
  const editorFilePath = useEditorStore((s) => s.filePath);

  const loadCommentsFromFile = useCallback(
    async (mdPath: string) => {
      setFilePath(mdPath);
      try {
        const content = await invoke<string>("read_comments", {
          path: mdPath,
        });
        if (content) {
          const data: CommentsFile = JSON.parse(content);
          loadComments(data);
        } else {
          loadComments({ version: 1, comments: {} });
        }
      } catch {
        loadComments({ version: 1, comments: {} });
      }
    },
    [loadComments, setFilePath],
  );

  const saveComments = useCallback(async () => {
    if (!editorFilePath) return;
    const data = getCommentsFile();
    const hasComments = Object.keys(data.comments).length > 0;

    if (hasComments) {
      const json = JSON.stringify(data, null, 2);
      await invoke("write_comments", {
        path: editorFilePath,
        content: json,
      });
    } else {
      await invoke("delete_comments", { path: editorFilePath });
    }
  }, [editorFilePath, getCommentsFile]);

  const generateCompanion = useCallback(
    async (markdownContent: string) => {
      if (!editorFilePath) return;
      const data = getCommentsFile();
      const hasComments = Object.keys(data.comments).length > 0;

      if (!hasComments) {
        await invoke("delete_companion", { path: editorFilePath });
        return;
      }

      const companion = buildCompanionMarkdown(
        editorFilePath,
        markdownContent,
        data,
      );
      await invoke("write_companion", {
        path: editorFilePath,
        content: companion,
      });
    },
    [editorFilePath, getCommentsFile],
  );

  return { loadCommentsFromFile, saveComments, generateCompanion };
}

const MARKER_RE = /<mark>([\s\S]*?)<\/mark><sup>\[c(\d+)\]<\/sup>/g;

export function buildCompanionMarkdown(
  filePath: string,
  markdownContent: string,
  commentsFile: CommentsFile,
): string {
  const fName = pathFileName(filePath) || "document.md";
  const lines: string[] = [];

  lines.push(`# Comments â€” ${fName}`);
  lines.push("");
  lines.push("*Generated by Gutter. Do not edit â€” regenerated on save.*");
  lines.push("");
  lines.push("---");

  // Extract anchors in document order
  const anchors: { id: string; text: string }[] = [];
  let match;
  const re = new RegExp(MARKER_RE.source, "g");
  while ((match = re.exec(markdownContent)) !== null) {
    let text = match[1];
    if (text.length > 80) text = text.slice(0, 80) + "...";
    anchors.push({ id: `c${match[2]}`, text });
  }

  // Also include unanchored threads
  const anchoredIds = new Set(anchors.map((a) => a.id));
  const allIds = Object.keys(commentsFile.comments);
  const unanchored = allIds.filter((id) => !anchoredIds.has(id));

  const orderedEntries = [
    ...anchors.map((a) => ({ id: a.id, text: a.text })),
    ...unanchored.map((id) => ({ id, text: "(unanchored)" })),
  ];

  const formatDate = (iso: string) => {
    const d = new Date(iso);
    return (
      d.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
      }) +
      " " +
      d.toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
      })
    );
  };

  let resolvedCount = 0;
  let openCount = 0;

  for (const entry of orderedEntries) {
    const thread = commentsFile.comments[entry.id];
    if (!thread) continue;

    lines.push("");
    lines.push(`> **[${entry.id}]** on "${entry.text}"`);
    lines.push("");

    for (const msg of thread.thread) {
      lines.push(`**${msg.author}** â€” ${formatDate(msg.timestamp)}`);
      lines.push(msg.body);
      lines.push("");
    }

    if (thread.resolved) {
      resolvedCount++;
      lines.push(
        `âœ… *Resolved by ${thread.resolvedBy} â€” ${thread.resolvedAt ? formatDate(thread.resolvedAt) : ""}*`,
      );
    } else {
      openCount++;
      lines.push("ðŸŸ¡ *Open*");
    }

    lines.push("");
    lines.push("---");
  }

  const total = resolvedCount + openCount;
  lines.push("");
  lines.push(
    `*${total} comment${total !== 1 ? "s" : ""} (${resolvedCount} resolved, ${openCount} open)*`,
  );
  lines.push("");

  return lines.join("\n");
}
